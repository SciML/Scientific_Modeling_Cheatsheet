<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scientific Modeling Cheatsheet – MATLAB – Python – Julia Quick Reference</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            background: #fafafa;
        }

        .container {
            display: flex;
            min-height: 100vh;
            background: white;
            position: relative;
        }

        /* Mobile menu toggle button */
        .menu-toggle {
            display: none;
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1001;
            background: #34495e;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        .menu-toggle:hover {
            background: #2c3e50;
        }

        /* Sidebar Navigation */
        .sidebar {
            width: 280px;
            min-width: 280px;
            background: #f5f5f5;
            border-right: 1px solid #e0e0e0;
            padding: 30px 25px;
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            flex-shrink: 0;
            transition: transform 0.3s ease;
        }

        .sidebar h3 {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sidebar ul {
            list-style: none;
            margin-bottom: 25px;
            padding-left: 0;
        }

        .sidebar li {
            margin-bottom: 10px;
        }

        .sidebar a {
            color: #666;
            text-decoration: none;
            font-size: 14px;
            display: block;
            padding: 5px 10px;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .sidebar a:hover {
            color: #000;
            background: rgba(0,0,0,0.08);
        }

        .sidebar .section-group {
            margin-bottom: 30px;
        }

        .sidebar .section-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 12px;
            font-size: 14px;
            padding-bottom: 5px;
            border-bottom: 1px solid #ddd;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            padding: 30px 40px;
            background: white;
            margin-left: 0;
            max-width: calc(100% - 280px);
            overflow-x: auto;
        }

        h1 {
            font-size: 28px;
            font-weight: normal;
            margin-bottom: 5px;
            color: #333;
        }

        .subtitle {
            font-size: 14px;
            color: #777;
            margin-bottom: 25px;
        }

        h2 {
            font-size: 20px;
            font-weight: normal;
            color: #333;
            margin-top: 35px;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #e0e0e0;
        }

        h3 {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 25px;
            font-size: 13px;
            background: white;
            border: 1px solid #ddd;
        }

        th {
            background: #34495e;
            font-weight: normal;
            text-align: left;
            padding: 8px 10px;
            color: white;
            font-size: 13px;
            border-right: 1px solid #2c3e50;
        }

        th:last-child {
            border-right: none;
        }

        th:first-child {
            width: 200px;
            background: #2c3e50;
        }

        td {
            padding: 6px 10px;
            border-bottom: 1px solid #eee;
            border-right: 1px solid #f0f0f0;
            vertical-align: top;
        }

        td:last-child {
            border-right: none;
        }

        td:first-child {
            background: #f9f9f9;
            font-weight: normal;
            color: #555;
            border-right: 1px solid #e0e0e0;
        }

        /* Language-specific background colors */
        td:nth-child(2) {
            background: #fef5f5;  /* MATLAB - Light Red */
        }

        td:nth-child(3) {
            background: #f5fef5;  /* Python - Light Green */
        }

        td:nth-child(4) {
            background: #f5f8fe;  /* Julia - Light Blue */
        }

        tr:last-child td {
            border-bottom: none;
        }

        /* Alternating row colors */
        tr:nth-child(even) td:nth-child(2) {
            background: #fef0f0;  /* MATLAB - Slightly darker red */
        }

        tr:nth-child(even) td:nth-child(3) {
            background: #f0fef0;  /* Python - Slightly darker green */
        }

        tr:nth-child(even) td:nth-child(4) {
            background: #f0f5fe;  /* Julia - Slightly darker blue */
        }

        tr:nth-child(even) td:first-child {
            background: #f5f5f5;
        }

        tr:hover td:nth-child(2) {
            background: #fee8e8 !important;
        }

        tr:hover td:nth-child(3) {
            background: #e8fee8 !important;
        }

        tr:hover td:nth-child(4) {
            background: #e8f0fe !important;
        }

        tr:hover td:first-child {
            background: #e8ecef !important;
        }

        /* Code styling */
        code {
            font-family: Consolas, Monaco, 'Courier New', monospace;
            font-size: 12px;
            background: transparent;
            padding: 0;
            color: #333;
        }

        td code {
            display: block;
            background: transparent;
            padding: 0;
            white-space: pre;
            line-height: 1.4;
            color: #333;
        }

        /* Notes */
        .note {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 12px 15px;
            margin: 20px 0;
            font-size: 13px;
        }

        .note strong {
            color: #856404;
        }

        /* Footer */
        .footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
            text-align: center;
            color: #6c757d;
            font-size: 13px;
        }

        .footer a {
            color: #0969da;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .menu-toggle {
                display: block;
            }

            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                z-index: 1000;
                transform: translateX(-100%);
                box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            }

            .sidebar.active {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
                max-width: 100%;
                padding: 60px 20px 20px 20px;
            }

            /* Make tables scrollable on mobile */
            table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
            }

            th, td {
                min-width: 150px;
            }

            th:first-child,
            td:first-child {
                position: sticky;
                left: 0;
                z-index: 10;
                background: #f9f9f9;
            }

            th:first-child {
                background: #2c3e50;
            }
        }

        @media (max-width: 768px) {
            .menu-toggle {
                top: 5px;
                left: 5px;
                padding: 8px 12px;
                font-size: 14px;
            }

            .sidebar {
                width: 250px;
                padding: 20px 15px;
            }

            .main-content {
                padding: 50px 15px 15px 15px;
            }

            h1 {
                font-size: 24px;
            }

            h2 {
                font-size: 18px;
                margin-top: 25px;
            }

            h3 {
                font-size: 16px;
            }

            table {
                font-size: 11px;
            }

            th, td {
                padding: 4px 6px;
                min-width: 120px;
            }

            code {
                font-size: 10px;
            }

            .note {
                font-size: 12px;
                padding: 8px;
            }
        }

        @media (max-width: 480px) {
            th, td {
                min-width: 100px;
            }

            .sidebar {
                width: 90%;
            }
        }

        /* Print styles */
        @media print {
            .sidebar {
                display: none;
            }

            .main-content {
                padding: 0;
            }

            .container {
                display: block;
            }
        }
    </style>
</head>
<body>
    <!-- Mobile menu toggle -->
    <button class="menu-toggle" onclick="toggleSidebar()">☰ Menu</button>

    <div class="container">
        <!-- Sidebar Navigation -->
        <aside class="sidebar">
            <h3>Contents</h3>

            <div class="section-group">
                <div class="section-title">Basics</div>
                <ul>
                    <li><a href="#dependencies">Dependencies</a></li>
                    <li><a href="#vectors">Creating Vectors</a></li>
                    <li><a href="#matrices">Creating Matrices</a></li>
                    <li><a href="#manipulating">Manipulating Arrays</a></li>
                    <li><a href="#accessing">Accessing Elements</a></li>
                    <li><a href="#math-ops">Math Operations</a></li>
                    <li><a href="#aggregation">Sum / Max / Min</a></li>
                    <li><a href="#programming">Programming</a></li>
                </ul>
            </div>

            <div class="section-group">
                <div class="section-title">Scientific Computing</div>
                <ul>
                    <li><a href="#ode">Differential Equations</a></li>
                    <li><a href="#nonlinear">Nonlinear Solving</a></li>
                    <li><a href="#optimization">Optimization</a></li>
                    <li><a href="#interpolation">Interpolation</a></li>
                    <li><a href="#integration">Integration</a></li>
                    <li><a href="#fft">FFT & Signal</a></li>
                    <li><a href="#statistics">Statistics</a></li>
                    <li><a href="#pde">PDEs</a></li>
                </ul>
            </div>

            <div class="section-group">
                <div class="section-title">Symbolic-Numeric Tooling</div>
                <ul>
                    <li><a href="#symbolic">Symbolic Computing</a></li>
                    <li><a href="#autodiff">Automatic Differentiation</a></li>
                    <li><a href="#modelingtoolkit">Component-Based Modeling</a></li>
                </ul>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <h1>Scientific Modeling Cheatsheet</h1>
            <p class="subtitle">MATLAB – Python – Julia Quick Reference</p>

            <!-- Note about MATLAB code -->
            <div class="note" style="margin-bottom: 30px;">
                <p><strong>Note on MATLAB Code:</strong> The MATLAB examples from the original QuantEcon sections have been verified. Additional MATLAB examples in the extended scientific computing sections have not been fully tested due to licensing constraints. We welcome community contributions to verify and fix any MATLAB code issues. Please submit corrections via pull request to the repository at <a href="https://github.com/SciML/Julia_Modeling_Workshop" target="_blank">https://github.com/SciML/Julia_Modeling_Workshop</a>.</p>
            </div>

            <!-- Dependencies Section -->
            <h2 id="dependencies">Dependencies and Setup</h2>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Basic numerical</td>
                        <td><code>% Built-in</code></td>
                        <td><code>import numpy as np
from numpy import linalg as la</code></td>
                        <td><code>using LinearAlgebra
using Statistics
using SparseArrays</code></td>
                    </tr>
                    <tr>
                        <td>Scientific computing</td>
                        <td><code>% Built-in ODE solvers</code></td>
                        <td><code>from scipy import integrate
from scipy import optimize</code></td>
                        <td><code>using DifferentialEquations
using Optimization
using NonlinearSolve</code></td>
                    </tr>
                    <tr>
                        <td>Plotting</td>
                        <td><code>% Built-in plotting</code></td>
                        <td><code>import matplotlib.pyplot as plt</code></td>
                        <td><code>using Plots</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Creating Vectors -->
            <h2 id="vectors">Creating Vectors</h2>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Row vector</td>
                        <td><code>A = [1 2 3]</code></td>
                        <td><code>A = np.array([[1, 2, 3]])</code></td>
                        <td><code>A = [1 2 3]</code></td>
                    </tr>
                    <tr>
                        <td>Column vector</td>
                        <td><code>A = [1; 2; 3]</code></td>
                        <td><code>A = np.array([[1], [2], [3]])</code></td>
                        <td><code>A = [1 2 3]'  # Transpose of row vector
A = [1; 2; 3]  # Using semicolons
A = [1, 2, 3]  # 1-D array (column)</code></td>
                    </tr>
                    <tr>
                        <td>1-D array</td>
                        <td><code>Not applicable</code></td>
                        <td><code>A = np.array([1, 2, 3])</code></td>
                        <td><code>A = [1, 2, 3]</code></td>
                    </tr>
                    <tr>
                        <td>Integers from 1 to n</td>
                        <td><code>A = 1:n</code></td>
                        <td><code>A = np.arange(1, n+1)</code></td>
                        <td><code>A = 1:n</code></td>
                    </tr>
                    <tr>
                        <td>Integers j to n, step k</td>
                        <td><code>A = j:k:n</code></td>
                        <td><code>A = np.arange(j, n+1, k)</code></td>
                        <td><code>A = j:k:n</code></td>
                    </tr>
                    <tr>
                        <td>Linearly spaced</td>
                        <td><code>A = linspace(1, 5, k)</code></td>
                        <td><code>A = np.linspace(1, 5, k)</code></td>
                        <td><code>A = range(1, 5, length=k)</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Creating Matrices -->
            <h2 id="matrices">Creating Matrices</h2>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Create matrix</td>
                        <td><code>A = [1 2; 3 4]</code></td>
                        <td><code>A = np.array([[1, 2], [3, 4]])</code></td>
                        <td><code>A = [1 2; 3 4]</code></td>
                    </tr>
                    <tr>
                        <td>Zeros</td>
                        <td><code>A = zeros(2, 2)</code></td>
                        <td><code>A = np.zeros((2, 2))</code></td>
                        <td><code>A = zeros(2, 2)</code></td>
                    </tr>
                    <tr>
                        <td>Ones</td>
                        <td><code>A = ones(2, 2)</code></td>
                        <td><code>A = np.ones((2, 2))</code></td>
                        <td><code>A = ones(2, 2)</code></td>
                    </tr>
                    <tr>
                        <td>Identity</td>
                        <td><code>A = eye(2)</code></td>
                        <td><code>A = np.eye(2)</code></td>
                        <td><code>A = I
A = Matrix(I, 2, 2)</code></td>
                    </tr>
                    <tr>
                        <td>Diagonal</td>
                        <td><code>A = diag([1 2 3])</code></td>
                        <td><code>A = np.diag([1, 2, 3])</code></td>
                        <td><code>A = Diagonal([1, 2, 3])</code></td>
                    </tr>
                    <tr>
                        <td>Random uniform</td>
                        <td><code>A = rand(2, 2)</code></td>
                        <td><code>A = np.random.rand(2, 2)</code></td>
                        <td><code>A = rand(2, 2)</code></td>
                    </tr>
                    <tr>
                        <td>Random normal</td>
                        <td><code>A = randn(2, 2)</code></td>
                        <td><code>A = np.random.randn(2, 2)</code></td>
                        <td><code>A = randn(2, 2)</code></td>
                    </tr>
                    <tr>
                        <td>Sparse</td>
                        <td><code>A = sparse(B)</code></td>
                        <td><code>from scipy import sparse
A = sparse.csr_matrix(B)</code></td>
                        <td><code>using SparseArrays
A = sparse(B)
# Create empty sparse matrix
A = spzeros(2, 2)
A[1, 2] = 4
A[2, 2] = 1</code></td>
                    </tr>
                    <tr>
                        <td>Tridiagonal</td>
                        <td><code>A = diag(x, -1) + diag(y, 0) + diag(z, 1)</code></td>
                        <td><code>from scipy.sparse import diags
A = diags([x, y, z], [-1, 0, 1])</code></td>
                        <td><code># Example vectors
x = [1, 2, 3]
y = [4, 5, 6, 7]
z = [8, 9, 10]
Tridiagonal(x, y, z)</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Manipulating Vectors and Matrices -->
            <h2 id="manipulating">Manipulating Vectors and Matrices</h2>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Transpose</td>
                        <td><code>A.'</code></td>
                        <td><code>A.T</code></td>
                        <td><code>transpose(A)
A'</code></td>
                    </tr>
                    <tr>
                        <td>Complex conjugate transpose</td>
                        <td><code>A'</code></td>
                        <td><code>A.conj().T</code></td>
                        <td><code>A'</code></td>
                    </tr>
                    <tr>
                        <td>Concatenate horizontally</td>
                        <td><code>A = [B C]</code></td>
                        <td><code>A = np.hstack([B, C])
A = np.concatenate([B, C], axis=1)</code></td>
                        <td><code>A = [[1 2] [1 2]]  # For literals
A = [B C]  # For variables
A = hcat(B, C)  # Function form</code></td>
                    </tr>
                    <tr>
                        <td>Concatenate vertically</td>
                        <td><code>A = [B; C]</code></td>
                        <td><code>A = np.vstack([B, C])
A = np.concatenate([B, C], axis=0)</code></td>
                        <td><code>A = [[1 2]; [1 2]]  # For literals
A = [B; C]  # For variables
A = vcat(B, C)  # Function form</code></td>
                    </tr>
                    <tr>
                        <td>Reshape (to 5x2)</td>
                        <td><code>A = reshape(A, 5, 2)</code></td>
                        <td><code>A = A.reshape(5, 2)</code></td>
                        <td><code>A = reshape(A, 5, 2)</code></td>
                    </tr>
                    <tr>
                        <td>Convert matrix to vector</td>
                        <td><code>A(:)</code></td>
                        <td><code>A.flatten()</code></td>
                        <td><code>A[:]
vec(A)</code></td>
                    </tr>
                    <tr>
                        <td>Flip left/right</td>
                        <td><code>fliplr(A)</code></td>
                        <td><code>np.fliplr(A)</code></td>
                        <td><code>reverse(A, dims=2)</code></td>
                    </tr>
                    <tr>
                        <td>Flip up/down</td>
                        <td><code>flipud(A)</code></td>
                        <td><code>np.flipud(A)</code></td>
                        <td><code>reverse(A, dims=1)</code></td>
                    </tr>
                    <tr>
                        <td>Repeat matrix (3x4 block)</td>
                        <td><code>repmat(A, 3, 4)</code></td>
                        <td><code>np.tile(A, (3, 4))</code></td>
                        <td><code>repeat(A, 3, 4)</code></td>
                    </tr>
                    <tr>
                        <td>Preallocate similar array</td>
                        <td><code>B = zeros(size(A))</code></td>
                        <td><code>B = np.empty_like(A)</code></td>
                        <td><code>x = rand(3, 3)
y = similar(x)
y = similar(x, 2, 2)</code></td>
                    </tr>
                    <tr>
                        <td>Broadcasting functions</td>
                        <td><code>arrayfun(@(x) x^2, A)</code></td>
                        <td><code>A**2  # NumPy broadcasts automatically</code></td>
                        <td><code>f(x) = x^2
g(x, y) = x + 2 + y^2
x = 1:10
y = 2:11
f.(x)  # Apply f to each element
g.(x, y)  # Apply g element-wise</code></td>
                    </tr>
                    <tr>
                        <td>Sort rows</td>
                        <td><code>sort(A)</code></td>
                        <td><code>np.sort(A)</code></td>
                        <td><code>sort(A, dims=1)</code></td>
                    </tr>
                    <tr>
                        <td>Sort columns</td>
                        <td><code>sort(A, 2)</code></td>
                        <td><code>np.sort(A, axis=1)</code></td>
                        <td><code>sort(A, dims=2)</code></td>
                    </tr>
                    <tr>
                        <td>Unique values</td>
                        <td><code>unique(A)</code></td>
                        <td><code>np.unique(A)</code></td>
                        <td><code>unique(A)</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Accessing Elements -->
            <h2 id="accessing">Accessing Vector/Matrix Elements</h2>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Access element (row i, col j)</td>
                        <td><code>A(i, j)</code></td>
                        <td><code>A[i-1, j-1]</code></td>
                        <td><code>A[i, j]</code></td>
                    </tr>
                    <tr>
                        <td>Access row i</td>
                        <td><code>A(i, :)</code></td>
                        <td><code>A[i-1, :]</code></td>
                        <td><code>A[i, :]</code></td>
                    </tr>
                    <tr>
                        <td>Access column j</td>
                        <td><code>A(:, j)</code></td>
                        <td><code>A[:, j-1]</code></td>
                        <td><code>A[:, j]</code></td>
                    </tr>
                    <tr>
                        <td>First k rows</td>
                        <td><code>A(1:k, :)</code></td>
                        <td><code>A[:k, :]</code></td>
                        <td><code>A[1:k, :]</code></td>
                    </tr>
                    <tr>
                        <td>First k columns</td>
                        <td><code>A(:, 1:k)</code></td>
                        <td><code>A[:, :k]</code></td>
                        <td><code>A[:, 1:k]</code></td>
                    </tr>
                    <tr>
                        <td>Last k rows</td>
                        <td><code>A(end-k+1:end, :)</code></td>
                        <td><code>A[-k:, :]</code></td>
                        <td><code>A[end-k+1:end, :]</code></td>
                    </tr>
                    <tr>
                        <td>Select rows [1, 3, 5]</td>
                        <td><code>A([1 3 5], :)</code></td>
                        <td><code>A[[0, 2, 4], :]</code></td>
                        <td><code>A[[1, 3, 5], :]</code></td>
                    </tr>
                    <tr>
                        <td>Remove row 2</td>
                        <td><code>A(2, :) = []</code></td>
                        <td><code>A = np.delete(A, 1, axis=0)</code></td>
                        <td><code>A = A[setdiff(1:end, 2), :]</code></td>
                    </tr>
                    <tr>
                        <td>Diagonal elements</td>
                        <td><code>diag(A)</code></td>
                        <td><code>np.diag(A)</code></td>
                        <td><code>diag(A)</code></td>
                    </tr>
                    <tr>
                        <td>Get dimensions</td>
                        <td><code>size(A)</code></td>
                        <td><code>A.shape</code></td>
                        <td><code>size(A)
nrow, ncol = size(A)</code></td>
                    </tr>
                    <tr>
                        <td>Number of dimensions</td>
                        <td><code>ndims(A)</code></td>
                        <td><code>A.ndim</code></td>
                        <td><code>ndims(A)</code></td>
                    </tr>
                    <tr>
                        <td>Number of elements</td>
                        <td><code>numel(A)</code></td>
                        <td><code>A.size</code></td>
                        <td><code>length(A)</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Mathematical Operations -->
            <h2 id="math-ops">Mathematical Operations</h2>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Dot product</td>
                        <td><code>dot(A, B)</code></td>
                        <td><code>np.dot(A, B)
A @ B</code></td>
                        <td><code>dot(A, B)
A ⋅ B</code></td>
                    </tr>
                    <tr>
                        <td>Matrix multiplication</td>
                        <td><code>A * B</code></td>
                        <td><code>A @ B
np.matmul(A, B)</code></td>
                        <td><code>A * B</code></td>
                    </tr>
                    <tr>
                        <td>Element-wise multiplication</td>
                        <td><code>A .* B</code></td>
                        <td><code>A * B</code></td>
                        <td><code>A .* B</code></td>
                    </tr>
                    <tr>
                        <td>Element-wise division</td>
                        <td><code>A ./ B</code></td>
                        <td><code>A / B</code></td>
                        <td><code>A ./ B</code></td>
                    </tr>
                    <tr>
                        <td>Element-wise power</td>
                        <td><code>A .^ 2</code></td>
                        <td><code>A ** 2</code></td>
                        <td><code>A .^ 2</code></td>
                    </tr>
                    <tr>
                        <td>Matrix power</td>
                        <td><code>A^2</code></td>
                        <td><code>np.linalg.matrix_power(A, 2)</code></td>
                        <td><code>A^2</code></td>
                    </tr>
                    <tr>
                        <td>Inverse</td>
                        <td><code>inv(A)</code></td>
                        <td><code>np.linalg.inv(A)</code></td>
                        <td><code>inv(A)</code></td>
                    </tr>
                    <tr>
                        <td>Determinant</td>
                        <td><code>det(A)</code></td>
                        <td><code>np.linalg.det(A)</code></td>
                        <td><code>det(A)</code></td>
                    </tr>
                    <tr>
                        <td>Eigenvalues & vectors</td>
                        <td><code>[V, D] = eig(A)</code></td>
                        <td><code>D, V = np.linalg.eig(A)</code></td>
                        <td><code>D, V = eigen(A)</code></td>
                    </tr>
                    <tr>
                        <td>Singular value decomposition</td>
                        <td><code>[U, S, V] = svd(A)</code></td>
                        <td><code>U, S, V = np.linalg.svd(A)</code></td>
                        <td><code>U, S, V = svd(A)</code></td>
                    </tr>
                    <tr>
                        <td>Cholesky decomposition</td>
                        <td><code>chol(A)</code></td>
                        <td><code>np.linalg.cholesky(A)</code></td>
                        <td><code>cholesky(A)</code></td>
                    </tr>
                    <tr>
                        <td>LU decomposition</td>
                        <td><code>[L, U, P] = lu(A)</code></td>
                        <td><code>P, L, U = scipy.linalg.lu(A)</code></td>
                        <td><code>L, U, p = lu(A)</code></td>
                    </tr>
                    <tr>
                        <td>QR decomposition</td>
                        <td><code>[Q, R] = qr(A)</code></td>
                        <td><code>Q, R = np.linalg.qr(A)</code></td>
                        <td><code>Q, R = qr(A)</code></td>
                    </tr>
                    <tr>
                        <td>Rank</td>
                        <td><code>rank(A)</code></td>
                        <td><code>np.linalg.matrix_rank(A)</code></td>
                        <td><code>rank(A)</code></td>
                    </tr>
                    <tr>
                        <td>Trace</td>
                        <td><code>trace(A)</code></td>
                        <td><code>np.trace(A)</code></td>
                        <td><code>tr(A)</code></td>
                    </tr>
                    <tr>
                        <td>Norm</td>
                        <td><code>norm(A)</code></td>
                        <td><code>np.linalg.norm(A)</code></td>
                        <td><code>norm(A)</code></td>
                    </tr>
                    <tr>
                        <td>Condition number</td>
                        <td><code>cond(A)</code></td>
                        <td><code>np.linalg.cond(A)</code></td>
                        <td><code>cond(A)</code></td>
                    </tr>
                    <tr>
                        <td>Solve Ax = b</td>
                        <td><code>A \ b</code></td>
                        <td><code>np.linalg.solve(A, b)</code></td>
                        <td><code>A \ b</code></td>
                    </tr>
                    <tr>
                        <td>Least squares</td>
                        <td><code>A \ b</code></td>
                        <td><code>np.linalg.lstsq(A, b)[0]</code></td>
                        <td><code>A \ b</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Sum / Max / Min -->
            <h2 id="aggregation">Sum / Max / Min</h2>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Sum of all elements</td>
                        <td><code>sum(A(:))</code></td>
                        <td><code>np.sum(A)</code></td>
                        <td><code>sum(A)</code></td>
                    </tr>
                    <tr>
                        <td>Sum along columns</td>
                        <td><code>sum(A)</code></td>
                        <td><code>np.sum(A, axis=0)</code></td>
                        <td><code>sum(A, dims=1)</code></td>
                    </tr>
                    <tr>
                        <td>Sum along rows</td>
                        <td><code>sum(A, 2)</code></td>
                        <td><code>np.sum(A, axis=1)</code></td>
                        <td><code>sum(A, dims=2)</code></td>
                    </tr>
                    <tr>
                        <td>Cumulative sum</td>
                        <td><code>cumsum(A)</code></td>
                        <td><code>np.cumsum(A)</code></td>
                        <td><code>cumsum(A)</code></td>
                    </tr>
                    <tr>
                        <td>Max of all elements</td>
                        <td><code>max(A(:))</code></td>
                        <td><code>np.max(A)</code></td>
                        <td><code>maximum(A)</code></td>
                    </tr>
                    <tr>
                        <td>Max along columns</td>
                        <td><code>max(A)</code></td>
                        <td><code>np.max(A, axis=0)</code></td>
                        <td><code>maximum(A, dims=1)</code></td>
                    </tr>
                    <tr>
                        <td>Max along rows</td>
                        <td><code>max(A, [], 2)</code></td>
                        <td><code>np.max(A, axis=1)</code></td>
                        <td><code>maximum(A, dims=2)</code></td>
                    </tr>
                    <tr>
                        <td>Max and index</td>
                        <td><code>[val, idx] = max(A)</code></td>
                        <td><code>idx = np.argmax(A)
val = A.flat[idx]</code></td>
                        <td><code>val, idx = findmax(A)</code></td>
                    </tr>
                    <tr>
                        <td>Min of all elements</td>
                        <td><code>min(A(:))</code></td>
                        <td><code>np.min(A)</code></td>
                        <td><code>minimum(A)</code></td>
                    </tr>
                    <tr>
                        <td>Min along columns</td>
                        <td><code>min(A)</code></td>
                        <td><code>np.min(A, axis=0)</code></td>
                        <td><code>minimum(A, dims=1)</code></td>
                    </tr>
                    <tr>
                        <td>Min along rows</td>
                        <td><code>min(A, [], 2)</code></td>
                        <td><code>np.min(A, axis=1)</code></td>
                        <td><code>minimum(A, dims=2)</code></td>
                    </tr>
                    <tr>
                        <td>Min and index</td>
                        <td><code>[val, idx] = min(A)</code></td>
                        <td><code>idx = np.argmin(A)
val = A.flat[idx]</code></td>
                        <td><code>val, idx = findmin(A)</code></td>
                    </tr>
                    <tr>
                        <td>Mean</td>
                        <td><code>mean(A)</code></td>
                        <td><code>np.mean(A)</code></td>
                        <td><code>mean(A)</code></td>
                    </tr>
                    <tr>
                        <td>Median</td>
                        <td><code>median(A)</code></td>
                        <td><code>np.median(A)</code></td>
                        <td><code>median(A)</code></td>
                    </tr>
                    <tr>
                        <td>Standard deviation</td>
                        <td><code>std(A)</code></td>
                        <td><code>np.std(A)</code></td>
                        <td><code>std(A)</code></td>
                    </tr>
                    <tr>
                        <td>Variance</td>
                        <td><code>var(A)</code></td>
                        <td><code>np.var(A)</code></td>
                        <td><code>var(A)</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Programming -->
            <h2 id="programming">Programming</h2>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Comment</td>
                        <td><code>% This is a comment</code></td>
                        <td><code># This is a comment</code></td>
                        <td><code># This is a comment</code></td>
                    </tr>
                    <tr>
                        <td>Multiline comment</td>
                        <td><code>%{
This is a
multiline comment
%}</code></td>
                        <td><code>"""
This is a
multiline comment
"""</code></td>
                        <td><code>#=
This is a
multiline comment
=#</code></td>
                    </tr>
                    <tr>
                        <td>For loop</td>
                        <td><code>for i = 1:10
    disp(i)
end</code></td>
                        <td><code>for i in range(1, 11):
    print(i)</code></td>
                        <td><code>for i in 1:10
    println(i)
end</code></td>
                    </tr>
                    <tr>
                        <td>While loop</td>
                        <td><code>while x < 10
    x = x + 1
end</code></td>
                        <td><code>while x < 10:
    x = x + 1</code></td>
                        <td><code>while x < 10
    x = x + 1
end</code></td>
                    </tr>
                    <tr>
                        <td>If statement</td>
                        <td><code>if x > 0
    disp('positive')
elseif x < 0
    disp('negative')
else
    disp('zero')
end</code></td>
                        <td><code>if x > 0:
    print('positive')
elif x < 0:
    print('negative')
else:
    print('zero')</code></td>
                        <td><code>if x > 0
    println("positive")
elseif x < 0
    println("negative")
else
    println("zero")
end</code></td>
                    </tr>
                    <tr>
                        <td>Function definition</td>
                        <td><code>function y = f(x)
    y = x^2;
end</code></td>
                        <td><code>def f(x):
    return x**2</code></td>
                        <td><code>function f(x)
    return x^2
end

f(x) = x^2</code></td>
                    </tr>
                    <tr>
                        <td>Anonymous function</td>
                        <td><code>f = @(x) x^2</code></td>
                        <td><code>f = lambda x: x**2</code></td>
                        <td><code>f = x -> x^2</code></td>
                    </tr>
                    <tr>
                        <td>Try-catch</td>
                        <td><code>try
    % code
catch ME
    disp(ME.message)
end</code></td>
                        <td><code>try:
    # code
except Exception as e:
    print(e)</code></td>
                        <td><code>try
    # code
catch e
    println(e)
end</code></td>
                    </tr>
                    <tr>
                        <td>Print to console</td>
                        <td><code>disp('text')
fprintf('text\n')</code></td>
                        <td><code>print('text')</code></td>
                        <td><code>println("text")
print("text")</code></td>
                    </tr>
                    <tr>
                        <td>String formatting</td>
                        <td><code>sprintf('x = %d', x)</code></td>
                        <td><code>f'x = {x}'
'x = {}'.format(x)</code></td>
                        <td><code>"x = $x"
@sprintf("x = %d", x)</code></td>
                    </tr>
                    <tr>
                        <td>Ternary operator</td>
                        <td><code>y = (x > 0) * 1 + (x <= 0) * (-1)</code></td>
                        <td><code>y = 1 if x > 0 else -1</code></td>
                        <td><code>y = x > 0 ? 1 : -1</code></td>
                    </tr>
                    <tr>
                        <td>List comprehension</td>
                        <td><code>y = arrayfun(@(x) x^2, 1:10)</code></td>
                        <td><code>y = [x**2 for x in range(1, 11)]</code></td>
                        <td><code>y = [x^2 for x in 1:10]</code></td>
                    </tr>
                    <tr>
                        <td>Map function</td>
                        <td><code>arrayfun(@(x) x^2, A)</code></td>
                        <td><code>list(map(lambda x: x**2, A))</code></td>
                        <td><code>map(x -> x^2, A)</code></td>
                    </tr>
                    <tr>
                        <td>Filter function</td>
                        <td><code>A(A > 0)</code></td>
                        <td><code>list(filter(lambda x: x > 0, A))</code></td>
                        <td><code>filter(x -> x > 0, A)</code></td>
                    </tr>
                    <tr>
                        <td>Type checking</td>
                        <td><code>isa(x, 'double')</code></td>
                        <td><code>isinstance(x, float)</code></td>
                        <td><code>isa(x, Float64)</code></td>
                    </tr>
                    <tr>
                        <td>Tuples</td>
                        <td><code>% Cell arrays serve similar purpose
A = {1, 'text', [1 2 3]}</code></td>
                        <td><code>t = (1, 'text', [1, 2, 3])
# Named tuple
from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
p = Point(1, 2)</code></td>
                        <td><code># Tuple
t = (1, "text", [1, 2, 3])
# Named tuple
t = (x=1, y=2, z=3)
t.x  # Access element
# Unpacking
a, b, c = t</code></td>
                    </tr>
                    <tr>
                        <td>Closures</td>
                        <td><code>function f = makemultiplier(x)
    function g = mult(y)
        g = x * y;
    end
    f = @mult;
end</code></td>
                        <td><code>def make_multiplier(x):
    def mult(y):
        return x * y
    return mult</code></td>
                        <td><code>function make_multiplier(x)
    return y -> x * y
end
# Or with mutable state
function counter()
    count = 0
    return () -> (count += 1)
end</code></td>
                    </tr>
                    <tr>
                        <td>In-place modification</td>
                        <td><code>A(:) = B(:)</code></td>
                        <td><code>A[:] = B[:]</code></td>
                        <td><code># Convention: ! indicates mutation
function f!(out, x)
    out .= x.^2
end
x = rand(10)
y = similar(x)
f!(y, x)

# ODE example
function mysys!(du, u, p, t)
    du[1] = u[2]
    du[2] = -u[1]
end

# Modify array in-place
A .= B  # Element-wise assignment
A .+= 1  # Add 1 to all elements</code></td>
                    </tr>
                    <tr>
                        <td>Timing code</td>
                        <td><code>tic; % code; toc</code></td>
                        <td><code>import time
start = time.time()
# code
print(time.time() - start)</code></td>
                        <td><code>@time begin
    # code
end</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Differential Equations Section -->
            <h2 id="ode">Differential Equations</h2>

            <h3>Single ODE: dy/dt = f(t,y)</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Define ODE</td>
                        <td><code>f = @(t,y) -2*y + sin(t)</code></td>
                        <td><code>def f(t, y):
    return -2*y + np.sin(t)</code></td>
                        <td><code>f(u, p, t) = -2*u + sin(t)</code></td>
                    </tr>
                    <tr>
                        <td>Solve ODE</td>
                        <td><code>[t, y] = ode45(f, [0, 10], 1)</code></td>
                        <td><code>from scipy.integrate import solve_ivp
sol = solve_ivp(f, [0, 10], [1])</code></td>
                        <td><code>prob = ODEProblem(f, 1.0, (0.0, 10.0))
sol = solve(prob)</code></td>
                    </tr>
                    <tr>
                        <td>Specify time points</td>
                        <td><code>tspan = 0:0.1:10;
[t, y] = ode45(f, tspan, 1)</code></td>
                        <td><code>t_eval = np.linspace(0, 10, 101)
sol = solve_ivp(f, [0, 10], [1],
                t_eval=t_eval)</code></td>
                        <td><code># Save at regular intervals
sol = solve(prob, saveat=0.1)
# Save at specific times (same as 0:0.1:10)
t_save = 0:0.1:10
sol = solve(prob, saveat=t_save)</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>System of ODEs</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Define system</td>
                        <td><code>function dydt = mysys(t, y)
    dydt = zeros(2,1);
    dydt(1) = y(2);
    dydt(2) = -y(1) - 0.1*y(2);
end</code></td>
                        <td><code>def mysys(t, y):
    return [y[1],
            -y[0] - 0.1*y[1]]</code></td>
                        <td><code>function mysys!(du, u, p, t)
    du[1] = u[2]
    du[2] = -u[1] - 0.1*u[2]
end</code></td>
                    </tr>
                    <tr>
                        <td>Solve system</td>
                        <td><code>[t, y] = ode45(@mysys, [0, 20], [1; 0])</code></td>
                        <td><code>sol = solve_ivp(mysys, [0, 20], [1, 0])</code></td>
                        <td><code>u0 = [1.0, 0.0]
tspan = (0.0, 20.0)
prob = ODEProblem(mysys!, u0, tspan)
sol = solve(prob)</code></td>
                    </tr>
                    <tr>
                        <td>Stiff solver</td>
                        <td><code>[t, y] = ode15s(@mysys, [0, 20], [1; 0])</code></td>
                        <td><code>sol = solve_ivp(mysys, [0, 20], [1, 0],
                method='BDF')</code></td>
                        <td><code>sol = solve(prob, FBDF())</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>DAEs (Mass Matrix Form): M*du/dt = f(u,p,t)</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Define mass matrix DAE</td>
                        <td><code>% ROBER DAE problem
M = [1 0 0; 0 1 0; 0 0 0];

function dydt = rober(t, y)
    k1 = 0.04; k2 = 3e7; k3 = 1e4;
    dydt = [-k1*y(1) + k3*y(2)*y(3);
            k1*y(1) - k2*y(2)^2 - k3*y(2)*y(3);
            y(1) + y(2) + y(3) - 1];
end</code></td>
                        <td><code># Not possible in SciPy
# Assimulo/SUNDIALS exist but
# are less maintained libraries</code></td>
                        <td><code># ROBER DAE example
using DifferentialEquations

function rober(du, u, p, t)
    y₁, y₂, y₃ = u
    k₁, k₂, k₃ = p
    du[1] = -k₁*y₁ + k₃*y₂*y₃
    du[2] = k₁*y₁ - k₂*y₂^2 - k₃*y₂*y₃
    du[3] = y₁ + y₂ + y₃ - 1
end

M = [1.0 0 0
     0   1.0 0
     0   0   0]  # singular mass matrix

f_ode = ODEFunction(rober, mass_matrix=M)
u0 = [1.0, 0, 0]
tspan = (0.0, 1e-5)
p = [0.04, 3e7, 1e4]
prob = ODEProblem(f_ode, u0, tspan, p)</code></td>
                    </tr>
                    <tr>
                        <td>Solve mass matrix DAE</td>
                        <td><code>options = odeset('Mass', M, ...
                  'MStateDependence', 'none');
y0 = [1; 0; 0];
[t, y] = ode15s(@rober, [0 1e-5], y0, options)</code></td>
                        <td><code># Not possible in SciPy</code></td>
                        <td><code>sol = solve(prob, Rodas5())
# Automatically detects DAE and uses
# appropriate algorithm</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>Fully Implicit DAEs: f(du/dt, u, p, t) = 0</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Define implicit DAE</td>
                        <td><code>function res = implicitdae(t, y, yp)
    % Residual form: res = f(t,y,y') = 0
    res = [yp(1) - y(2);
           yp(2) + 9.81 + y(3)*y(1);
           y(1)^2 + y(2)^2 - 1];
end</code></td>
                        <td><code># Not possible in SciPy
# Assimulo/SUNDIALS exist but are
# less maintained third-party libraries
# Example would use assimulo.solvers.IDA</code></td>
                        <td><code>using DifferentialEquations

function residual!(res, du, u, p, t)
    res[1] = du[1] - u[2]
    res[2] = du[2] + 9.81 + u[3]*u[1]
    res[3] = u[1]^2 + u[2]^2 - 1
end

prob = DAEProblem(residual!, du0, u0, tspan,
                  differential_vars=[true,true,false])</code></td>
                    </tr>
                    <tr>
                        <td>Solve implicit DAE</td>
                        <td><code>[y0, yp0] = decic(@implicitdae, 0, ...
                  guess_y, [], guess_yp, []);
[t, y] = ode15i(@implicitdae, [0 10], y0, yp0)</code></td>
                        <td><code># Would require Assimulo installation
# and IDA solver setup</code></td>
                        <td><code>using Sundials
sol = solve(prob, IDA())
# or DFBDF() for stiff DAEs</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Nonlinear Equation Solving -->
            <h2 id="nonlinear">Nonlinear Equation Solving</h2>

            <h3>Single Equation</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Find root</td>
                        <td><code>f = @(x) x^3 - 2*x - 5;
x = fzero(f, 2)</code></td>
                        <td><code>from scipy.optimize import fsolve
f = lambda x: x**3 - 2*x - 5
x = fsolve(f, 2)</code></td>
                        <td><code>using NonlinearSolve
f(u, p) = u^3 - 2u - 5
prob = NonlinearProblem(f, 2.0)
sol = solve(prob)</code></td>
                    </tr>
                    <tr>
                        <td>With derivative</td>
                        <td><code>f = @(x) x^3 - 2*x - 5;
df = @(x) 3*x^2 - 2;
x = fzero(@(x) [f(x), df(x)], 2)</code></td>
                        <td><code>from scipy.optimize import newton
f = lambda x: x**3 - 2*x - 5
df = lambda x: 3*x**2 - 2
x = newton(f, 2, fprime=df)</code></td>
                        <td><code>f(u, p) = u^3 - 2u - 5
df(u, p) = 3u^2 - 2
prob = NonlinearProblem(f, 2.0)
sol = solve(prob, NewtonRaphson())</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>System of Equations</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Define system</td>
                        <td><code>function F = mysys(x)
    F = [x(1)^2 + x(2)^2 - 1;
         x(1) - x(2)^2];
end</code></td>
                        <td><code>def mysys(x):
    return [x[0]**2 + x[1]**2 - 1,
            x[0] - x[1]**2]</code></td>
                        <td><code>function mysys!(F, x)
    F[1] = x[1]^2 + x[2]^2 - 1
    F[2] = x[1] - x[2]^2
end</code></td>
                    </tr>
                    <tr>
                        <td>Solve</td>
                        <td><code>x0 = [1; 1];
x = fsolve(@mysys, x0)</code></td>
                        <td><code>x0 = [1, 1]
x = fsolve(mysys, x0)</code></td>
                        <td><code>using NonlinearSolve
x0 = [1.0, 1.0]
prob = NonlinearProblem(mysys!, x0)
sol = solve(prob)</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Optimization -->
            <h2 id="optimization">Optimization</h2>

            <!-- Compatibility Warning -->
            <div class="note" style="background: #fff3cd; border-color: #ffc107; margin-bottom: 20px;">
                <p><strong>⚠️ Python Compatibility Warning:</strong> SciPy optimization (used in this section) is incompatible with:</p>
                <ul style="margin: 5px 0; padding-left: 20px;">
                    <li>PyTorch autodiff - Cannot use PyTorch gradients with scipy.optimize</li>
                    <li>PyTorch optimizers (torch.optim) - Different API and tensor requirements</li>
                    <li>CasADi optimization - Must use CasADi's own solvers</li>
                </ul>
                <p style="margin-top: 10px;">For gradient-based optimization with autodiff, PyTorch requires using torch.optim optimizers (Adam, SGD, etc.) with tensor inputs.</p>
            </div>

            <h3>Unconstrained</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Minimize scalar</td>
                        <td><code>f = @(x) (x-2)^2 + 3;
x = fminbnd(f, 0, 5)</code></td>
                        <td><code>from scipy.optimize import minimize_scalar
f = lambda x: (x-2)**2 + 3
res = minimize_scalar(f, bounds=(0, 5),
                     method='bounded')</code></td>
                        <td><code>using Optimization, OptimizationOptimJL
f(x, p) = (first(x)-2)^2 + 3
prob = OptimizationProblem(f, [2.5], lb=[0.0], ub=[5.0])
sol = solve(prob)</code></td>
                    </tr>
                    <tr>
                        <td>Minimize multivariate</td>
                        <td><code>f = @(x) x(1)^2 + x(2)^2;
x0 = [0; 0];
x = fminsearch(f, x0)</code></td>
                        <td><code>from scipy.optimize import minimize
f = lambda x: x[0]**2 + x[1]**2
x0 = [0, 0]
res = minimize(f, x0)</code></td>
                        <td><code>f(x, p) = x[1]^2 + x[2]^2
prob = OptimizationProblem(f, [0.0, 0.0])
sol = solve(prob, Optim.LBFGS())</code></td>
                    </tr>
                    <tr>
                        <td>With gradient</td>
                        <td><code>options = optimoptions('fminunc',
                       'GradObj','on');
x = fminunc(@(x) deal(f(x), grad(x)),
            x0, options)</code></td>
                        <td><code>def grad(x):
    return np.array([2*x[0], 2*x[1]])
res = minimize(f, x0, jac=grad)</code></td>
                        <td><code>using OptimizationOptimJL, ADTypes
f(x, p) = x[1]^2 + x[2]^2
optf = OptimizationFunction(f, ADTypes.AutoForwardDiff())
prob = OptimizationProblem(optf, [0.0, 0.0])
sol = solve(prob, Optim.LBFGS())</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>Constrained</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Box constraints</td>
                        <td><code>lb = [0; 0]; ub = [1; 1];
x = fmincon(f, x0, [], [], [], [], lb, ub)</code></td>
                        <td><code>bounds = [(0, 1), (0, 1)]
res = minimize(f, x0, bounds=bounds)</code></td>
                        <td><code>prob = OptimizationProblem(f, [0.5, 0.5],
                          lb=[0.0, 0.0], ub=[1.0, 1.0])
sol = solve(prob)</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Interpolation -->
            <h2 id="interpolation">Interpolation and Curve Fitting</h2>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Linear interpolation</td>
                        <td><code>x = [1, 2, 3, 4, 5];
y = [2, 4, 1, 3, 5];
xi = 1:0.1:5;
yi = interp1(x, y, xi, 'linear')</code></td>
                        <td><code>from scipy import interpolate
f = interpolate.interp1d(x, y)
xi = np.linspace(1, 5, 41)
yi = f(xi)</code></td>
                        <td><code>using DataInterpolations
itp = LinearInterpolation(y, x)
xi = 1:0.1:5
yi = itp.(xi)</code></td>
                    </tr>
                    <tr>
                        <td>Cubic spline</td>
                        <td><code>yi = interp1(x, y, xi, 'spline')</code></td>
                        <td><code>f = interpolate.interp1d(x, y, kind='cubic')
yi = f(xi)</code></td>
                        <td><code>itp = CubicSpline(y, x)
yi = itp.(xi)</code></td>
                    </tr>
                    <tr>
                        <td>Polynomial fit</td>
                        <td><code>p = polyfit(x, y, 2);
yfit = polyval(p, x)</code></td>
                        <td><code>p = np.polyfit(x, y, 2)
yfit = np.polyval(p, x)</code></td>
                        <td><code>using Polynomials
p = fit(x, y, 2)
yfit = p.(x)</code></td>
                    </tr>
                    <tr>
                        <td>Nonlinear fit</td>
                        <td><code>model = @(b,x) b(1)*exp(b(2)*x);
b0 = [1, 0.1];
b = lsqcurvefit(model, b0, x, y)</code></td>
                        <td><code>from scipy.optimize import curve_fit
def model(x, a, b):
    return a * np.exp(b * x)
popt, pcov = curve_fit(model, x, y)</code></td>
                        <td><code>using NonlinearSolve
function model!(resid, p, (x, y))
    pred = p[1] * exp.(p[2] * x)
    resid .= y .- pred
end
prob = NonlinearLeastSquaresProblem(model!, [1.0, 0.1], (x, y))
sol = solve(prob)</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Integration -->
            <h2 id="integration">Numerical Integration</h2>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>1D integration</td>
                        <td><code>f = @(x) exp(-x.^2);
I = integral(f, 0, 1)</code></td>
                        <td><code>from scipy import integrate
f = lambda x: np.exp(-x**2)
I, err = integrate.quad(f, 0, 1)</code></td>
                        <td><code>using Integrals
f(x, p) = exp(-x^2)
prob = IntegralProblem(f, 0, 1)
sol = solve(prob, QuadGKJL())
I = sol.u</code></td>
                    </tr>
                    <tr>
                        <td>2D integration</td>
                        <td><code>f = @(x,y) exp(-x.^2 - y.^2);
I = integral2(f, 0, 1, 0, 1)</code></td>
                        <td><code>f = lambda y, x: np.exp(-x**2 - y**2)
I, err = integrate.dblquad(f, 0, 1, 0, 1)</code></td>
                        <td><code>using Integrals
f(x, p) = exp(-x[1]^2 - x[2]^2)
prob = IntegralProblem(f, [0, 0], [1, 1])
sol = solve(prob, HCubatureJL())
I = sol.u</code></td>
                    </tr>
                    <tr>
                        <td>Trapezoidal</td>
                        <td><code>x = linspace(0, 1, 100);
y = exp(-x.^2);
I = trapz(x, y)</code></td>
                        <td><code>x = np.linspace(0, 1, 100)
y = np.exp(-x**2)
I = np.trapz(y, x)</code></td>
                        <td><code>using DataInterpolations
x = range(0, 1, length=100)
y = exp.(-x.^2)
itp = LinearInterpolation(y, x)
I = DataInterpolations.integral(itp, first(x), last(x))</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- FFT -->
            <h2 id="fft">FFT and Signal Processing</h2>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>FFT</td>
                        <td><code>y = fft(x);
freq = (0:length(x)-1)*fs/length(x);</code></td>
                        <td><code>y = np.fft.fft(x)
freq = np.fft.fftfreq(len(x), 1/fs)</code></td>
                        <td><code>using FFTW
y = fft(x)
freq = fftfreq(length(x), fs)</code></td>
                    </tr>
                    <tr>
                        <td>Inverse FFT</td>
                        <td><code>x = ifft(y)</code></td>
                        <td><code>x = np.fft.ifft(y)</code></td>
                        <td><code>x = ifft(y)</code></td>
                    </tr>
                    <tr>
                        <td>Power spectrum</td>
                        <td><code>[pxx, f] = pwelch(x, [], [], [], fs)</code></td>
                        <td><code>from scipy import signal
f, pxx = signal.welch(x, fs)</code></td>
                        <td><code>using DSP
pxx = welch_pgram(x, fs=fs)</code></td>
                    </tr>
                    <tr>
                        <td>Filter (lowpass)</td>
                        <td><code>[b, a] = butter(4, 0.2);
y = filter(b, a, x)</code></td>
                        <td><code>b, a = signal.butter(4, 0.2)
y = signal.filtfilt(b, a, x)</code></td>
                        <td><code>using DSP
H = Butterworth(4, 0.2)
y = filt(H, x)</code></td>
                    </tr>
                    <tr>
                        <td>Convolution</td>
                        <td><code>y = conv(x, h)</code></td>
                        <td><code>y = np.convolve(x, h)</code></td>
                        <td><code>y = conv(x, h)</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Statistics -->
            <h2 id="statistics">Statistics and Distributions</h2>

            <h3>Statistical Functions</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Mean, std</td>
                        <td><code>m = mean(x);
s = std(x);</code></td>
                        <td><code>m = np.mean(x)
s = np.std(x)</code></td>
                        <td><code>using Statistics
m = mean(x)
s = std(x)</code></td>
                    </tr>
                    <tr>
                        <td>Median, quantiles</td>
                        <td><code>med = median(x);
q = quantile(x, [0.25, 0.75]);</code></td>
                        <td><code>med = np.median(x)
q = np.quantile(x, [0.25, 0.75])</code></td>
                        <td><code>med = median(x)
q = quantile(x, [0.25, 0.75])</code></td>
                    </tr>
                    <tr>
                        <td>Correlation</td>
                        <td><code>R = corrcoef(x, y)</code></td>
                        <td><code>R = np.corrcoef(x, y)</code></td>
                        <td><code>R = cor(x, y)</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>Distributions</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Normal</td>
                        <td><code>x = randn(100, 1);
y = normrnd(mu, sigma, [100, 1]);
p = normpdf(x, mu, sigma);</code></td>
                        <td><code>from scipy import stats
x = np.random.randn(100)
y = np.random.normal(mu, sigma, 100)
p = stats.norm.pdf(x, mu, sigma)</code></td>
                        <td><code>using Distributions
d = Normal(mu, sigma)
x = rand(d, 100)
p = pdf(d, x)</code></td>
                    </tr>
                    <tr>
                        <td>Uniform</td>
                        <td><code>x = rand(100, 1);
y = unifrnd(a, b, [100, 1]);</code></td>
                        <td><code>x = np.random.rand(100)
y = np.random.uniform(a, b, 100)</code></td>
                        <td><code>d = Uniform(a, b)
x = rand(d, 100)</code></td>
                    </tr>
                    <tr>
                        <td>Fit to data</td>
                        <td><code>pd = fitdist(x, 'Normal');
params = pd.ParameterValues;</code></td>
                        <td><code>params = stats.norm.fit(x)</code></td>
                        <td><code>d = fit(Normal, x)</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- PDEs -->
            <h2 id="pde">Partial Differential Equations</h2>

            <h3>1D Heat Equation: ∂u/∂t = α∂²u/∂x²</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Method of lines</td>
                        <td><code>% Spatial discretization
nx = 50; dx = 1/(nx-1);
x = linspace(0, 1, nx)';
D2 = gallery('tridiag', nx, 1, -2, 1)/dx^2;

% Time integration
alpha = 0.01;
f = @(t,u) alpha*D2*u;
[t, u] = ode45(f, [0, 1], sin(pi*x));</code></td>
                        <td><code># Spatial discretization
nx = 50
x = np.linspace(0, 1, nx)
dx = x[1] - x[0]
D2 = (np.diag(np.ones(nx-1), 1) -
      2*np.diag(np.ones(nx), 0) +
      np.diag(np.ones(nx-1), -1))/dx**2

# Time integration
alpha = 0.01
def f(t, u):
    return alpha * D2 @ u
sol = solve_ivp(f, [0, 1], np.sin(np.pi*x))</code></td>
                        <td><code># Spatial discretization
nx = 50
x = range(0, 1, length=nx)
dx = x[2] - x[1]
D2 = Tridiagonal(ones(nx-1), -2*ones(nx),
                 ones(nx-1))/dx^2

# Time integration
α = 0.01
f!(du, u, p, t) = mul!(du, α*D2, u)
prob = ODEProblem(f!, sin.(π*x), (0.0, 1.0))
sol = solve(prob)</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Symbolic Computing -->
            <h2 id="symbolic">Symbolic Computing</h2>

            <!-- Compatibility Warning -->
            <div class="note" style="background: #fff3cd; border-color: #ffc107; margin-bottom: 20px;">
                <p><strong>⚠️ Python Compatibility Warning:</strong> SymPy (used for Python symbolic computing) is incompatible with:</p>
                <ul style="margin: 5px 0; padding-left: 20px;">
                    <li>PyTorch tensors - SymPy uses its own symbolic types, cannot mix with tensors</li>
                    <li>CasADi - Both are symbolic systems with incompatible representations</li>
                    <li>SciPy operations - Cannot use SciPy functions on symbolic expressions</li>
                    <li>NumPy arrays in symbolic expressions - must use SymPy operations</li>
                </ul>
            </div>

            <h3>Basic Symbolic Operations</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Define symbols</td>
                        <td><code>syms x y z</code></td>
                        <td><code>import sympy as sp
x, y, z = sp.symbols('x y z')</code></td>
                        <td><code>using Symbolics
@variables x y z</code></td>
                    </tr>
                    <tr>
                        <td>Create expression</td>
                        <td><code>expr = x^2 + 2*x*y + y^2</code></td>
                        <td><code>expr = x**2 + 2*x*y + y**2</code></td>
                        <td><code>expr = x^2 + 2*x*y + y^2</code></td>
                    </tr>
                    <tr>
                        <td>Substitute values</td>
                        <td><code>subs(expr, x, 2)</code></td>
                        <td><code>expr.subs(x, 2)</code></td>
                        <td><code>substitute(expr, x => 2)</code></td>
                    </tr>
                    <tr>
                        <td>Simplify</td>
                        <td><code>simplify(expr)</code></td>
                        <td><code>sp.simplify(expr)</code></td>
                        <td><code>simplify(expr)</code></td>
                    </tr>
                    <tr>
                        <td>Expand</td>
                        <td><code>expand(expr)</code></td>
                        <td><code>sp.expand(expr)</code></td>
                        <td><code>expand(expr)</code></td>
                    </tr>
                    <tr>
                        <td>Factor</td>
                        <td><code>factor(expr)</code></td>
                        <td><code>sp.factor(expr)</code></td>
                        <td><code>using SymbolicUtils
SymbolicUtils.simplify(expr)</code></td>
                    </tr>
                    <tr>
                        <td>Generate function (out-of-place)</td>
                        <td><code>matlabFunction(expr, 'Vars', [x, y])</code></td>
                        <td><code>f = sp.lambdify([x, y], expr)</code></td>
                        <td><code>f = build_function(expr, [x, y])
f_expr = eval(f[1])</code></td>
                    </tr>
                    <tr>
                        <td>Generate function (in-place)</td>
                        <td><code>% Not available natively</code></td>
                        <td><code># Not available in SymPy</code></td>
                        <td><code>f = build_function(expr, [x, y])
f! = eval(f[2])  # mutating version</code></td>
                    </tr>
                    <tr>
                        <td>Symbolic in numerical solver</td>
                        <td><code>% Not compatible with ODE solvers</code></td>
                        <td><code># Not compatible with scipy.integrate</code></td>
                        <td><code># Can use symbolic parameters in ODE solvers
using DifferentialEquations, Symbolics
@variables t x(t) a b
D = Differential(t)
eqs = [D(x) ~ a*x + b]
@named sys = System(eqs)
sys = complete(sys)

# Solve with symbolic parameters
u0 = [x => 1.0]
tspan = (0.0, 1.0)
p = [a => -2.0, b => 1.0]
prob = ODEProblem(sys, u0, tspan, p)
sol = solve(prob, Euler(), dt=0.25, adaptive=false)</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>Calculus</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Derivative</td>
                        <td><code>diff(expr, x)</code></td>
                        <td><code>sp.diff(expr, x)</code></td>
                        <td><code>D = Differential(x)
expand_derivatives(D(expr))</code></td>
                    </tr>
                    <tr>
                        <td>Partial derivative</td>
                        <td><code>diff(expr, x, 2)</code></td>
                        <td><code>sp.diff(expr, x, 2)</code></td>
                        <td><code>D = Differential(x)
expand_derivatives(D^2(expr))</code></td>
                    </tr>
                    <tr>
                        <td>Gradient</td>
                        <td><code>gradient(f, [x, y, z])</code></td>
                        <td><code>[sp.diff(f, var) for var in [x, y, z]]</code></td>
                        <td><code>Symbolics.gradient(f, [x, y, z])</code></td>
                    </tr>
                    <tr>
                        <td>Jacobian</td>
                        <td><code>jacobian([f1; f2], [x, y])</code></td>
                        <td><code>sp.Matrix([f1, f2]).jacobian([x, y])</code></td>
                        <td><code>Symbolics.jacobian([f1, f2], [x, y])</code></td>
                    </tr>
                    <tr>
                        <td>Integral (indefinite)</td>
                        <td><code>int(expr, x)</code></td>
                        <td><code>sp.integrate(expr, x)</code></td>
                        <td><code>using SymbolicIntegration
symbolic_integrate(expr, x)</code></td>
                    </tr>
                    <tr>
                        <td>Integral (definite)</td>
                        <td><code>int(expr, x, a, b)</code></td>
                        <td><code>sp.integrate(expr, (x, a, b))</code></td>
                        <td><code>using Integrals, Symbolics
f = build_function(expr, x)
prob = IntegralProblem((u,p) -> f[1](u), (a, b))
solve(prob, QuadGKJL())</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>Equation Solving</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Solve equation</td>
                        <td><code>solve(x^2 - 4 == 0, x)</code></td>
                        <td><code>sp.solve(x**2 - 4, x)</code></td>
                        <td><code>using Symbolics
symbolic_solve(x^2 - 4, x)</code></td>
                    </tr>
                    <tr>
                        <td>Solve system</td>
                        <td><code>solve([x + y == 5, x - y == 1], [x, y])</code></td>
                        <td><code>sp.solve([x + y - 5, x - y - 1], [x, y])</code></td>
                        <td><code>using Symbolics
symbolic_solve([x + y ~ 5, x - y ~ 1], [x, y])</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Automatic Differentiation -->
            <h2 id="autodiff">Automatic Differentiation</h2>

            <!-- Compatibility Warning -->
            <div class="note" style="background: #fff3cd; border-color: #ffc107; margin-bottom: 20px;">
                <p><strong>⚠️ Python Compatibility Warning:</strong> PyTorch (used for AD) is incompatible with:</p>
                <ul style="margin: 5px 0; padding-left: 20px;">
                    <li>SciPy functions (scipy.integrate, scipy.optimize, etc.) - must use PyTorch equivalents or pure Python</li>
                    <li>NumPy operations - must convert arrays to tensors and use torch functions</li>
                    <li>CasADi (used in Component-Based Modeling section) - cannot mix symbolic and AD frameworks</li>
                </ul>
            </div>

            <h3>Forward Mode AD</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Setup</td>
                        <td><code>% Not available natively</code></td>
                        <td><code>import torch</code></td>
                        <td><code>using ForwardDiff</code></td>
                    </tr>
                    <tr>
                        <td>Gradient (scalar → scalar)</td>
                        <td><code>% Not available natively
% Use symbolic or finite differences</code></td>
                        <td><code>from torch.autograd.functional import jvp

def f(x):
    return x**2 + torch.sin(x)

x = torch.tensor(2.0)
v = torch.tensor(1.0)  # tangent vector
y, df = jvp(f, x, v)  # df is derivative at x=2.0</code></td>
                        <td><code>f(x) = x^2 + sin(x)
df = ForwardDiff.derivative(f, 2.0)</code></td>
                    </tr>
                    <tr>
                        <td>Gradient (vector → scalar)</td>
                        <td><code>% Not available natively</code></td>
                        <td><code>from torch.autograd.functional import jvp

def f(x):
    return torch.sum(x**2)

x = torch.tensor([1.0, 2.0])
# Compute gradient via multiple forward passes
grad = []
for i in range(2):
    v = torch.zeros(2)
    v[i] = 1.0
    _, g = jvp(f, x, v)
    grad.append(g)
grad = torch.stack(grad)</code></td>
                        <td><code>f(x) = sum(x.^2)
grad = ForwardDiff.gradient(f, [1.0, 2.0])</code></td>
                    </tr>
                    <tr>
                        <td>Jacobian</td>
                        <td><code>% Not available natively</code></td>
                        <td><code>from torch.autograd.functional import jacobian

def f(x):
    return torch.stack([x[0]**2, x[0]*x[1]])

x = torch.tensor([1.0, 2.0])
jac = jacobian(f, x)</code></td>
                        <td><code>f(x) = [x[1]^2, x[1]*x[2]]
jac = ForwardDiff.jacobian(f, [1.0, 2.0])</code></td>
                    </tr>
                    <tr>
                        <td>Hessian</td>
                        <td><code>% Not available natively</code></td>
                        <td><code>from torch.autograd.functional import hessian

def f(x):
    return torch.sum(x**2)  # scalar function for Hessian

x = torch.tensor([1.0, 2.0])
hess = hessian(f, x)</code></td>
                        <td><code>hess = ForwardDiff.hessian(f, [1.0, 2.0])</code></td>
                    </tr>
                    <tr>
                        <td>Dual numbers</td>
                        <td><code>% Not available natively</code></td>
                        <td><code># Not exposed</code></td>
                        <td><code>using ForwardDiff
x = ForwardDiff.Dual(2.0, 1.0)
y = x^2 + sin(x)
# value: y.value
# derivative: y.partials[1]</code></td>
                    </tr>
                    <tr>
                        <td>Consistency requirements</td>
                        <td><code>% N/A</code></td>
                        <td><code># Must replace ALL NumPy/SciPy calls:
# np.sin → torch.sin
# scipy.integrate → not compatible
# scipy.optimize → not compatible
# Cannot use with CasADi</code></td>
                        <td><code># ForwardDiff: requires generic functions
# (no explicit Float64 types)
# Must use generic operations
# e.g. zero(x) instead of 0.0</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>Reverse Mode AD (Backpropagation)</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Setup</td>
                        <td><code>% Not available natively</code></td>
                        <td><code>import torch</code></td>
                        <td><code>using Enzyme</code></td>
                    </tr>
                    <tr>
                        <td>Gradient</td>
                        <td><code>% Not available natively</code></td>
                        <td><code>def f(x):
    return x**2 + torch.sin(x)

x = torch.tensor(2.0, requires_grad=True)
y = f(x)
y.backward()
grad = x.grad  # gradient at x=2.0</code></td>
                        <td><code>f(x) = x^2 + sin(x)
x = 2.0
dx = 0.0
autodiff(Reverse, f, Active, Duplicated(x, Ref(dx)))
# gradient is in dx</code></td>
                    </tr>
                    <tr>
                        <td>Vector gradient</td>
                        <td><code>% Not available natively</code></td>
                        <td><code>def f(x):
    return torch.sum(x**2)

x = torch.tensor([1.0, 2.0], requires_grad=True)
y = f(x)
y.backward()
grad = x.grad  # gradient at [1.0, 2.0]</code></td>
                        <td><code>f(x) = sum(x.^2)
x = [1.0, 2.0]
dx = zero(x)
autodiff(Reverse, f, Active, Duplicated(x, dx))
# gradient is in dx</code></td>
                    </tr>
                    <tr>
                        <td>Jacobian-vector product (JVP)</td>
                        <td><code>% Not available natively</code></td>
                        <td><code>from torch.autograd.functional import jvp

def f(x):
    return torch.stack([x[0]**2, x[0]*x[1], x[1]**2])

x = torch.tensor([2.0, 3.0])
v = torch.tensor([1.0, 0.0])  # tangent vector
y, jvp_result = jvp(f, x, v)</code></td>
                        <td><code>f(x) = [x[1]^2, x[1]*x[2], x[2]^2]
x = [2.0, 3.0]
v = [1.0, 0.0]  # tangent vector
y, jvp = autodiff(Forward, f, Duplicated, Duplicated(x, v))
# jvp contains J*v</code></td>
                    </tr>
                    <tr>
                        <td>Vector-Jacobian product (VJP)</td>
                        <td><code>% Not available natively</code></td>
                        <td><code>def f(x):
    return torch.stack([x[0]**2, x[0]*x[1], x[1]**2])

x = torch.tensor([2.0, 3.0], requires_grad=True)
y = f(x)
v = torch.tensor([1.0, 0.0, 1.0])  # cotangent vector
y.backward(v)
vjp = x.grad  # v^T * J</code></td>
                        <td><code>function f!(y, x)
    y[1] = x[1]^2
    y[2] = x[1]*x[2]
    y[3] = x[2]^2
end
x = [2.0, 3.0]
y = zeros(3)
dx = zeros(2)
dy = [1.0, 0.0, 1.0]  # cotangent vector
autodiff(Reverse, f!, Const,
         Duplicated(y, dy), Duplicated(x, dx))
# dx contains v^T * J</code></td>
                    </tr>
                    <tr>
                        <td>Consistency requirements</td>
                        <td><code>% N/A</code></td>
                        <td><code># Must replace ALL NumPy/SciPy calls:
# np.exp → torch.exp
# scipy functions → not compatible
# No mixed tensor/array operations
# Incompatible with CasADi</code></td>
                        <td><code># Enzyme: works with most Julia code
# Including mutating functions, BLAS
# Type-stable code recommended
# for best performance</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Component-Based Modeling -->
            <h2 id="modelingtoolkit">Component-Based Modeling</h2>

            <!-- Compatibility Warning -->
            <div class="note" style="background: #fff3cd; border-color: #ffc107; margin-bottom: 20px;">
                <p><strong>⚠️ Python Compatibility Warning:</strong> This section uses CasADi for Python examples, which is incompatible with:</p>
                <ul style="margin: 5px 0; padding-left: 20px;">
                    <li>PyTorch tensors - CasADi uses its own symbolic types</li>
                    <li>SciPy solvers on CasADi functions - must use CasADi's own solvers</li>
                    <li>NumPy operations on symbolic expressions - use CasADi operations</li>
                </ul>
                <p style="margin-top: 10px;">Julia's ModelingToolkit.jl uses the same solvers from earlier sections (DifferentialEquations.jl, NonlinearSolve.jl, Optimization.jl).</p>
            </div>

            <h3>System Definition</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Define ODE system (Cartesian pendulum)</td>
                        <td><code>% Use Simulink or write function</code></td>
                        <td><code>import casadi as ca

x = ca.SX.sym('x')
y = ca.SX.sym('y')
vx = ca.SX.sym('vx')
vy = ca.SX.sym('vy')
lam = ca.SX.sym('lam')

states = ca.vertcat(x, y, vx, vy, lam)
odes = ca.vertcat(vx, vy, -lam*x, -lam*y - 9.81)
algs = x**2 + y**2 - 1

dae = {'x': states, 'ode': odes, 'alg': algs}</code></td>
                        <td><code>using ModelingToolkit

@parameters t g L
@variables x(t) y(t) vx(t) vy(t) λ(t)
D = Differential(t)

eqs = [D(x) ~ vx,
       D(y) ~ vy,
       D(vx) ~ -λ * x/L,
       D(vy) ~ -λ * y/L - g,
       x^2 + y^2 ~ L^2]

@named pendulum = System(eqs)</code></td>
                    </tr>
                    <tr>
                        <td>Simplify system</td>
                        <td><code>% Manual simplification</code></td>
                        <td><code># CasADi cannot do acausal simplification</code></td>
                        <td><code>pendulum = complete(pendulum)
pendulum_simplified = mtkcompile(pendulum)</code></td>
                    </tr>
                    <tr>
                        <td>Transient simulation</td>
                        <td><code>% Create function handle and solve</code></td>
                        <td><code># Note: CasADi cannot directly solve
# this DAE model - would need integrator
# setup with algebraic constraints,
# high index causes instability</code></td>
                        <td><code>u0 = [x => 1.0, y => 0.0,
      vx => 0.0, vy => 0.0]
tspan = (0.0, 10.0)
p = [g => 9.81, L => 1.0]

prob = ODEProblem(pendulum_simplified, u0, tspan, p)
sol = solve(prob)</code></td>
                    </tr>
                    <tr>
                        <td>Steady state solutions</td>
                        <td><code>% Use fsolve or symbolic solve</code></td>
                        <td><code># CasADi has its own rootfinder
import casadi as ca
# Create rootfinder for algebraic equations
rf = ca.rootfinder('rf', 'newton', dae)
sol = rf(x0, p)</code></td>
                        <td><code>ss_prob = NonlinearProblem(
    pendulum_simplified, u0, p)
ss_sol = solve(ss_prob)</code></td>
                    </tr>
                    <tr>
                        <td>Generate LaTeX</td>
                        <td><code>% Not available for Simulink models</code></td>
                        <td><code># Not available in CasADi</code></td>
                        <td><code>using Latexify
latexify(pendulum)</code></td>
                    </tr>
                </tbody>
            </table>


            <h3>Component-Based Modeling</h3>
            <table>
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>MATLAB</th>
                        <th>Python</th>
                        <th>Julia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Create component</td>
                        <td><code>% Use Simulink blocks</code></td>
                        <td><code># No direct equivalent
# Consider PyMola or OpenModelica</code></td>
                        <td><code>function Mass(; name, m = 1.0,
              x = 0.0, v = 0.0)
    @parameters t
    @variables x(t) v(t) F(t)
    @parameters m
    D = Differential(t)

    eqs = [D(x) ~ v,
           D(v) ~ F/m]

    System(eqs, t, [x, v, F], [m]; name)
end

@named mass1 = Mass(m = 2.0)</code></td>
                    </tr>
                    <tr>
                        <td>Connect systems</td>
                        <td><code>% Simulink connections</code></td>
                        <td><code># Manual composition</code></td>
                        <td><code>@named spring = Spring(k = 100)
@named damper = Damper(c = 10)

connections = [
    spring.x ~ mass1.x,
    damper.x ~ mass1.x,
    mass1.F ~ spring.F + damper.F
]

@named model = System(connections, t,
                        systems = [mass1, spring, damper])
model = complete(model)</code></td>
                    </tr>
                    <tr>
                        <td>Simplify</td>
                        <td><code>% Simulink cannot simplify</code></td>
                        <td><code># Manual</code></td>
                        <td><code>model_simplified = mtkcompile(model)</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Footer -->
            <footer class="footer">
                <p>Extended from <a href="https://cheatsheets.quantecon.org/" target="_blank">QuantEcon Cheatsheets</a> for Scientific Computing</p>
                <p>Contributors: Scientific Computing Community</p>
            </footer>
        </main>
    </div>

    <script>
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            sidebar.classList.toggle('active');
        }

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(event) {
            const sidebar = document.querySelector('.sidebar');
            const menuToggle = document.querySelector('.menu-toggle');

            if (window.innerWidth <= 1024) {
                if (!sidebar.contains(event.target) && !menuToggle.contains(event.target)) {
                    sidebar.classList.remove('active');
                }
            }
        });

        // Close sidebar when clicking on a link on mobile
        document.querySelectorAll('.sidebar a').forEach(link => {
            link.addEventListener('click', function() {
                if (window.innerWidth <= 1024) {
                    document.querySelector('.sidebar').classList.remove('active');
                }
            });
        });
    </script>
</body>
</html>